| Namn | Förklaring | Reflektion och regler från Clean Code |
|------|------------|---------------------------------------|
| `SubscriptionCollection`| Klassnamn för att hantera samling av prenumerationer | **Class Names:** Använder substantiv som Clean Code rekommenderar för klasser. **Use Intention-Revealing Names:** Namnet kommunicerar både vad den innehåller (Subscriptions) och hur den organiseras (Collection). Namnet ändrades från 'Manager' till 'Collection' under den här processen för att uppnå just detta.|
| `calculateMonthlyCost(subscription)` | Metodnamn för att beräkna månadskostnad för en prenumeration | **Use Intention-Revealing Names:** Namnet talar om exakt vad metoden gör, både operationen (calculate) och resultatet (MonthlyCost). **Method Names:** Verbet 'calculate' används här för att markera att det är en beräkning, till skillnad från 'get' som vanligtvis används för att hämta ett lagrat värde. **Pick One Word per Concept:** Konsekvent användning av 'calculate' för alla kostnadsberäkningar i klassen CostCalculator. **Use Pronounceable Names:** Lätt att uttala och diskutera. |
| `isActive()` | Metodnamn som returnerar boolean för aktiv status på en subscription| **Method Names:** 'is' markerar att returvärdet är boolean. **Make Meaningful Distinctions:** Skiljer sig från `activate()` som ändrar status, medan `isActive()` bara returnerar den. **Avoid Mental Mapping:** Ingen översättning behövs, namnet talar om vad det returnerar. |
| `searchSubscriptionsByName(name)` | Metodnamn för att söka prenumerationer | **Pick One Word per Concept:** Konsekvent användning av "search" för sökoperationer och "get" för direkthämtning. **Avoid Disinformation:** "search" indikerar sökning tills skillnad från "get" som skulle implicera en exakt matchning. **Add Meaningful Context:** "ByName" förtydligar sökkriteriet men namnet misslyckas med att kommunicera case-insensitive partial matching. JSDoc krävs här för att kompensera för namnets begränsningar. |
| `findUnderutilizedSubscriptions()` | Metodnamn som hittar underutnyttjade prenumerationer | **Use Intention-Revealing Names:** Beskrivande namn med god understandability men längden riskerar att ge sämre readability (modulens längsta namn). Alternativa namn övervägdes men hade lett till förlorad precision. **Use Problem Domain Names:** "Underutilized" använder problemdomänens språk för att beskriva prenumerationer som kostar mycket relativt till användning. |


## Reflektion Kapitel 2: Namngivning
Under utvecklingen av min modul insåg jag tidigt hur viktigt det är att balansera beskrivande namn med läsbarhet. Mitt längsta metodnamn, ’findUnderutilizedSubscriptions()’, är tydligt men med 31 tecken blir det så pass lång att det kan påverka kodflödet negativt. Clean Code betonar att längre namn är bättre än otydliga, men jag inser att det finns en gräns där längden blir kontraproduktiv. Trots längden valde jag att behålla namnet då andra alternativ som ’findExpensiveByUsage()’, förlorade precision i vad metoden faktiskt gör.

Jag har tillämpat ’Use Intention-Revealing Names’ genom hela modulen, vilket gjorde koden överlag självdokumenterande. Jag har även sett till att namn är pronounceable och undviker mental mapping. Namn som ’calculateMonthlyCost()’ är lätt att uttala, förstå och diskutera med kollegor, till skillnad från förkortningar som ’calcMoCost()’. Användaren ska inte behöva översätta eller mappa namn mentalt för att förstå vad de gör. Målet är att hålla koden mer tillgänglig och minska kognitiv belastning.

Ett exempel på namnbyte är klassnamnet ’SubscriptionManager’ som jag ändrade till ’SubscriptionCollection’ då ’Manager’ är för generiskt. ’Collection’ beskriver vad klassen faktiskt gör, hanterar en samling objekt snarare än att ’hantera’ dem i bredare bemärkelse.

En viktig designreflektion var valet mellan getMonthlyCost() och calculateMonthlyCost(). Jag valde ’calculate’ då metoden utför beräkningar och transformationer snarare än att bara returnera ett lagrat värde. Detta följer ’Make Meaningful Distinctions’ där get/calculate indikerar olika typer av operationer för användaren. I Subscription-klassen använder jag begreppet ’Price’ (ex. getPrice() ) för att hänvisa till det faktiska pris som användaren angett, medan CostCalculator använder calculate-metoder för att konvertera detta pris mellan olika tidsfrekvenser (weekly/monthly/yearly). På samma sätt skiljer jag mellan ’search’ (partial matching) och ’get’ (direkt hämtning) i SubscriptionCollection. Jag har varit konsekvent med dessa verb-distinktioner genom hela modulen och undvikit ordlekar eller dubbelmeningar.

Jag har även varit medveten om att balansera problem domain names och solution domain names, begrepp som var helt nya för mig. "Underutilized" i ’findUnderutilizedSubscriptions()’ kommer från problemdomänen och beskriver prenumerationer som kostar mycket relativt till användning. Detta gör metoden begriplig för den som förstår affärsproblemet, medan tekniska namn som ’Collection’ och ’Calculator’ kommer från solution domain och är välkända programmeringskoncept.

Gällande kontext i namn övervägde jag om ’getSubscriptionsByCategory()’ innehåller onödig upprepning av ’Subscriptions’ när metoden redan finns i klassen SubscriptionCollection. Men jag anser att det är en viktig kontext eftersom metoden returnerar Subscription-objekt. Jag undviker däremot gratuitous context genom att inte prefixa metoder med klassnamnet.

Användningen av konstanter som VALID_FREQUENCIES och HOURS_PER_WEEK undviker magiska strängar och nummer enligt ’Use Searchable Names’. Dessa namn är lätta att söka efter i koden och gör den mer underhållbar. Jag använder även JavaScript's moderna # för privata fält istället för äldre konventioner, vilket följer ’Avoid Encodings’ genom att låta språket självt hantera synlighet.

Ett viktigt koncept från föreläsningen är painted types. I min Subscription-klass är ’category’ en painted type, en string utan validering, till skillnad från exempelvis frequency som valideras mot VALID_FREQUENCIES. Detta är ett medvetet designval där jag i modulen prioriterar användaren/utvecklarens flexibilitet att kunna skapa egna kategorier efter sina önskemål och överlåter till användaren att implementera riktiga typer vid behov.



## Tabell 2: Funktioner (Kapitel 3)

De 5 längsta metoderna ur totalt 29 publika metoder. 

| Metodnamn | Länk eller kod | Antal rader (ej ws) | Reflektion |
|-----------|----------------|---------------------|------------|
| `findUnderutilizedSubscriptions()` | [src/UsageAnalyzer.js](src/UsageAnalyzer.js#L33) | 18 | **Do One Thing:** Metoden bryter mot regeln genom att filtrera, beräkna och bygga resultat. **Förslag:** Dela upp i 3 privata metoder (`#filterUsable`, `#calculateCosts`, `#buildResults`). **Valt:** Behålla for-loop för tydligare flöde av komplex logik.  **Small Functions:** Metoden är nära Clean Code's gräns på max 20 rader, men ändå inom gränsen för vad som är acceptabelt. **Function Arguments:** Triadic vilket är problematiskt enligt Clean Code. Designvalet att inte injicera costCalculator via konstruktorn beror på att inte alla metoder i UsageAnalyzer behöver den och skulle få onödigt beroende. Trade-offen är att denna metod blir triadic, men varje metod är explicit om sina beroenden. **Command Query Separation:** Är en ren query utan sidoeffekter. |
| `calculateHourlyCost()`, `calculateMonthlyCost()`, `calculateYearlyCost()`, `calculateWeeklyCost()` | [src/CostCalculator.js](src/CostCalculator.js#L46) | 15, 12, 12, 12 | **Do One Thing:** Varje metod har ett tydligt ansvar - konvertera till specifik tidsfrekvens. **Function Arguments:** Monadic vilket är acceptabelt. **Structured Programming:** Använder flera returns istället för en exit point, vilket gör koden plattare och mer lättläst än djupt nästlade if/else-block. **Don't Repeat Yourself:** Duplicerad struktur mellan metoderna men med olika konverteringskunskap. **Förslag:** Extrahera till generisk metod `#convertCost(subscription, targetFrequency)`. **Valt:** Behålla separata metoder eftersom varje innehåller unik konverteringskunskap och en generisk lösning skulle skapa onödig komplexitet. |
| `constructor (Subscription)` | [src/Subscription.js](src/Subscription.js#L31) | 11 | **Do One Thing:** Konstruktorn initialiserar och validerar. **Function Arguments:** Polyadic (4 parametrar varav en med default) vilket inte är optimalt. **Förslag:** Configuration object `new Subscription({ name, price, frequency, category })` för att minska till 1 argument. **Valt:** Parameter-lista för enkelhet och tydlig ordning i denna modulstorlek. **Prefer Exceptions to Returning Error Codes:** Följer 'fail fast' genom att validera alla inputs och kastar exceptions före initialisering, vilket säkerställer att systemet endast innehåller giltiga Subscription-objekt. |
| `analyzeCostPerHour()` | [src/UsageAnalyzer.js](src/UsageAnalyzer.js#L17) | 6 | **Do One Thing:** Gör en sak - analyserar kostnad per timme. **Function Arguments:** Dyadic vilket är acceptabelt. **Förslag:** Injicera costCalculator via konstruktor. **Valt:** Parameter-passing för att hålla UsageAnalyzer oberoende av calculator för metoder som inte behöver den. **Prefer Exceptions to Returning Error Codes:** Kastar exception vid division med noll istället för att returnera felkod. **Command Query Separation:** Ren query utan sidoeffekter. |
| `addUsageHours()` | [src/Subscription.js](src/Subscription.js#L129) | 6 | **Do One Thing:** Gör en sak - lägger till timmar med validering. **Function Arguments:** Monadic vilket är acceptabelt. **Command Query Separation:** Är ett command som ändrar state utan att returnera värde, vilket följer CQS korrekt. **Have No Side Effects:** Tack vare det tydliga namnet (`add`) räknas state-förändringen inte som sidoeffekt eftersom metoden gör vad namnet lovar. **Prefer Exceptions to Returning Error Codes:** Kastar exception vid negativa värden istället för att returnera felkod. |


## Reflektion Kapitel 3: Funktioner
Under arbetet med modulen visade sig principerna ’Do One Thing’ och ’Small functions’ vara väldigt utmanande och tvingade mig att omvärdera hur jag tänker kring metodansvar. Överlag tycker jag att jag lyckats hålla ner komplexiteten och storleken på mina metoder men jag har några enstaka exempel som bryter mot detta, se tabell 2. Det fanns även några metoder jag funderade över som calculateMonthlyCost() kan tyckas bryta mot 'Do One Thing' då den innehåller flera beräkningar. Men jag valde att behålla den då metodens logiska ansvar är en sak: att beräkna månadskostnaden och namnet reflekterar detta. De olika if-satserna är implementationsdetaljer för att hantera olika frekvenser. Att dela upp metoden skulle göra koden svårare att läsa. Metoderna använder if/else-kedjor istället för switch-satser eftersom det bara finns två till tre fall att hantera, och if/else ger bättre läsbarhet för denna enkla logik.

Jag arbetade medvetet med abstraktionsnivåer genom att använda privata hjälpmetoder. I `calculateCostByCategory()` delegerar jag till `#filterActiveSubscriptions()` och `#groupCostsByCategory()` vilket håller den publika metoden på hög abstraktionsnivå medan hjälpmetoderna hanterar detaljer. På samma sätt använder `searchSubscriptionsByName()` den privata metoden `#matchesName()` för att hantera den lågnivålogiken med toLowerCase() och includes(). Detta följer principen om att läsa kod från topp till botten där användaren ser först vad som händer på hög nivå, sedan kan de välja att fördjupa sig i implementationen.

En princip jag tillämpat genom hela modulen är Command Query Separation (CQS). Metoder som `activate()` och `addUsageHours()` är kommandon som ändrar state utan att returnera värden, medan `isActive()` och alla calculate-metoder är queries som returnerar värden utan att ändra state. Detta gjorde koden mer förutsägbar. Det enda undantaget är `removeSubscription()` som returnerar boolean för att indikera om borttagningen lyckades, ett aktivt val för att öka användbarheten.

En viktig insikt var min refaktorering av findUnusedSubscriptions() från for-loop med push till filter(). Detta gav både kortare kod och högre abstraktionsnivå. För findUnderutilizedSubscriptions() som hade liknande problematik övervägde jag method chaining men insåg att ett "tåg" av filter().map().filter() skulle dölja den komplexa logiken. For-loopen gör det tydligt att metoden både filtrerar och beräknar. Detta var en avvägning mellan högre abstraktion och explicit kod.

Jag har arbetat med att hålla blocks and indenting enkla genom låga indenteringsnivåer och små funktioner. If/while-block hålls korta och nästling undviks där det är möjligt genom att extrahera till privata metoder. Jag har även strukturerat klasserna så att publika metoder kommer först följt av privata hjälpmetoder, vilket underlättar för användaren att först förstå det publika interface.

I CostCalculator har beräkningsmetoderna liknande if/else-struktur. Jag övervägde först om det var ett DRY-brott men insåg vid närmare granskning att varje metod innehåller unik kunskap om sin specifika konvertering. Strukturen är samma men kunskapen är olika. Att extrahera till en generisk metod skulle göra koden mer komplex utan verkligt värde. DRY handlar om duplicerad kunskap, inte bara duplicerad struktur.

Jag har strävat efter ’Use descriptive names’, där namnet tydligt kommunicerar vad metoden gör och minskar behovet för kommentarer, något jag utvecklar mer i reflektionen över kapitel 2 namngivning. För side effects har jag varit vaksam på att metoder gör exakt vad namnet lovar. Exempelvis kommunicerar addUsageHours() tydligt att state kommer att ändras.

För felhantering följer modulen strikt 'Prefer Exceptions to Returning Error Codes'. Metoderna kastar exceptions med beskrivande meddelanden vid felaktig input istället för att returnera null eller felkoder. Detta gör felhanteringen tydligare och tvingar användaren att hantera fel korrekt. Det är sedan applikationens ansvar att fånga och hantera dessa exceptions med try/catch.

## Reflektion över egen kodkvalitet
Det har varit en väldigt lärorik process att tillämpa Clean Code-principer i utvecklingen av min modul. Under arbetet insåg jag hur givande och tidssparande det är med självdokumenterande kod, inte bara för andra utan även mig själv. Jag är van vid omfattande JSDoc-dokumentation enligt LNU-standard. Det var en märklig upplevelse att inse hur mycket av dokumentationen som blev överflödig när koden talar för sig själv.

Jag har strävat efter att skapa en välstrukturerad modul med tydlig separation of concerns med olika klasser för olika ansvarsområden. Användning av privata metoder för att hålla publika metoder så små och fokuserade som möjligt, namngivna konstanter eliminerade magiska nummer och Command Query Separation tillämpades konsekvent. Förbättringsområden finns naturligtvis både i koden och i min förståelse av principerna, vilket jag vill vara transparent med i den här reflektionen.

Genom denna assignment tar jag med mig vikten av att ’kommunicera lösningen, inte bara lösa problemet’. Den omfattande API-dokumentationen och de tydliga felmeddelanden som jag skapat hoppas jag kan hjälpa andra utvecklare förstå koden likväl som att få den att fungera.

Att analysera modulen utifrån Clean Code-perspektiv har varit en ögonöppnare och krävt mycket tankeverksamhet. I varje designval tvingades jag reflektera över hur en utomstående utvecklare ska förstå koden, vilket ställde mig inför konstanta vägskäl. Att följa Clean Code i alla avseenden har varit omöjligt för mig, vissa principer hamnar i konflikt med varandra, och jag har många gånger fått låta kontexten avgöra vilket val som är mest lämpligt. Alla beslut har nog inte varit 'rätt' men jag har reflekterat och lärt mig väldigt mycket. Det är jag tacksam för.


