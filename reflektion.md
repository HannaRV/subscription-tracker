## Tabell 1: Namngivning (Kapitel 2)
| Namn | Förklaring | Reflektion och regler från Clean Code |
|------|------------|---------------------------------------|
| `SubscriptionCollection`| Klassnamn för att hantera samling av prenumerationer | **Class Names:** Använder substantiv som Clean Code rekommenderar för klasser. **Use Intention-Revealing Names:** Namnet kommunicerar både vad den innehåller (Subscriptions) och hur den organiseras (Collection). Namnet ändrades från 'Manager' till 'Collection' under den här processen för att uppnå just detta.|
| `calculateMonthlyCost(subscription)` | Metodnamn för att beräkna månadskostnad för en prenumeration | **Use Intention-Revealing Names:** Namnet talar om exakt vad metoden gör, både operationen (calculate) och resultatet (MonthlyCost). **Method Names:** Verbet 'calculate' används här för att markera att det är en beräkning, till skillnad från 'get' som vanligtvis används för att hämta ett lagrat värde. **Pick One Word per Concept:** Konsekvent användning av 'calculate' för alla kostnadsberäkningar i klassen CostCalculator. **Use Pronounceable Names:** Lätt att uttala och diskutera. |
| `isActive()` | Metodnamn som returnerar boolean för aktiv status på en subscription| **Method Names:** 'is' markerar att returvärdet är boolean. **Make Meaningful Distinctions:** Skiljer sig från `activate()` som ändrar status, medan `isActive()` bara returnerar den. **Avoid Mental Mapping:** Ingen översättning behövs, namnet talar om vad det returnerar. |
| `searchSubscriptionsByName(name)` | Metodnamn för att söka prenumerationer | **Pick One Word per Concept:** Konsekvent användning av 'search' för sökoperationer och 'get' för direkthämtning. **Avoid Disinformation:** 'search' indikerar sökning till skillnad från 'get' som skulle implicera en exakt matchning. **Add Meaningful Context:** 'ByName' förtydligar sökkriteriet men namnet misslyckas med att kommunicera case-insensitive partial matching. JSDoc krävs här för att kompensera för namnets begränsningar. |
| `findUnderutilizedSubscriptions()` | Metodnamn som hittar underutnyttjade prenumerationer | **Use Intention-Revealing Names:** Beskrivande namn med god understandability men längden riskerar att ge sämre readability (modulens längsta namn). Alternativa namn övervägdes men hade lett till förlorad precision. **Use Problem Domain Names:** "Underutilized" använder problemdomänens språk för att beskriva prenumerationer som kostar mycket relativt till användning. |

## Reflektion Kapitel 2: Namngivning
Under utvecklingen av min modul visade sig namngivning vara mer utmanande än jag trodde och krävde betydligt mer eftertanke än vad jag tidigare gett det. Mitt längsta metodnamn är 'findUnderutilizedSubscriptions()' med 31 tecken. Namnet är tydligt med sin uppgift men jag har brottats med tanken att längden kan påverka kodens läsbarhet. Jag testade kortare alternativ som 'findExpensiveByUsage()', men de förlorade precision i vad som faktiskt utförs. Clean Code betonar att längre namn är bättre än otydliga och jag fick luta mig mot att precision i namnet vägde tyngst i detta fall.

Genom tillämpning av 'Use Intention-Revealing Names' genom hela modulen har koden blivit i det närmaste självdokumenterande. Det tillsammans med att hålla namn  pronounceable och undvika mental mapping, gör koden både lättare att förstå och diskutera med andra. Detta fick mig att inse att tid spenderad på namngivning faktiskt sparar tid senare, inte bara för andra som läser koden utan även för mig själv.  Namn som 'calculateMonthlyCost()' gör koden mer begriplig och tillgänglig än 'calcMoCost()' gör.

Ett konkret exempel på hur jag itererat med namn är klassnamnet 'SubscriptionManager' som jag ändrade relativt sent under processen till 'SubscriptionCollection'. Ursprungligen fastnade jag för ordet 'Manager' då det kändes klockrent för mig, men insåg att det var för generiskt och intetsägande för någon som inte är insatt i klassen. Vad gör en manager egentligen? 'Collection' däremot säger exakt vad klassen gör: hanterar en samling objekt. Vilka objekt? Jo, subscriptions. En viktig lärdom här var att det som känns självklart för mig behöver inte nödvändigtvis vara det för någon annan och ju mer information jag kan ge genom namnet desto lättare gör jag det för andra att sätta sig in i min kod.

En viktig designreflektion var valet mellan namngivningen getMonthlyCost() och calculateMonthlyCost(). Jag valde kalla metoden för 'calculate' då den utför beräkningar och transformationer snarare än att bara hämta ett lagrat värde. Detta följer 'Make Meaningful Distinctions' där get/calculate indikerar olika typer av operationer för användaren. I Subscription klassen använder jag medvetet begreppet 'Price' (ex. getPrice()) för att hänvisa till det faktiska pris som användaren angett för abonnemanget, medan CostCalculator använder begreppet 'cost' tillsammans med calculate metoder för att konvertera detta pris till kostnader mellan olika tidsfrekvenser (ex. calculateYearlyCost()). 

På samma sätt skiljer jag mellan 'search' (partial matching) och 'get' (direkt hämtning) i SubscriptionCollection. Jag har varit konsekvent med dessa verb-distinktioner genom hela modulen och arbetat aktivt med att undvika tvetydighet.

Problem domain vs solution domain names var ett helt nytt koncept för mig. Tidigare har jag använt tekniska namn genomgående. Att använda 'underutilized' från problemdomänen gjorde metoden begriplig för någon som förstår affärsproblemet, medan tekniska namn som 'Collection' och 'Calculator' är välkända för utvecklare. Jag lärde mig här att välja namn baserat på vem som ska förstå dem där affärslogik kan gynnas av problem domain names och teknisk infrastruktur av solution domain names.

Gällande kontext i namn övervägde jag om namn som 'getSubscriptionsByCategory()' innehåller onödig upprepning av 'Subscriptions' när metoden redan finns i klassen SubscriptionCollection. Genom att ta bort det hade jag fått ett kortare namn. Men jag anser att det är viktig kontext trots allt då metoden returnerar Subscription-objekt. Jag får välja mina ’battles’ och undviker gratuitous context genom att inte prefixa metoder med klassnamnet.

I min modul använder jag mig av konstanter som VALID_FREQUENCIES och HOURS_PER_WEEK för att undvika magiska strängar och nummer enligt 'Use Searchable Names' principen. Dessa namn är lätta att söka efter i koden och gör den mer underhållbar. Jag använder även JavaScript's moderna # för privata fält istället för äldre konventioner, vilket följer 'Avoid Encodings' genom att låta språket självt hantera synlighet.

Ett viktigt koncept från föreläsningen är painted types. I min Subscription klass är 'category' en painted type, en string utan validering, till skillnad från frequency som valideras mot VALID_FREQUENCIES. Detta är ett medvetet designval där modulen prioriterar användarens flexibilitet att kunna skapa kategorier efter egna önskemål, och överlåter därmed till användaren att implementera riktiga typer vid behov.


## Tabell 2: Funktioner (Kapitel 3)

De 5 längsta metoderna ur totalt 29 publika metoder. 

| Metodnamn | Länk eller kod | Antal rader (ej ws) | Reflektion |
|-----------|----------------|---------------------|------------|
| `findUnderutilizedSubscriptions()` | [src/UsageAnalyzer.js](src/UsageAnalyzer.js#L33) | 18 | **Do One Thing:** Metoden bryter mot regeln genom att filtrera, beräkna och bygga resultat. **Förslag:** Dela upp i 3 privata metoder (`#filterUsable`, `#calculateCosts`, `#buildResults`). **Valt:** Behålla for-loop för tydligare flöde av komplex logik.  **Small Functions:** Metoden är nära Clean Code's gräns på max 20 rader, men ändå inom gränsen för vad som är acceptabelt. **Function Arguments:** Triadic vilket är problematiskt enligt Clean Code. Designvalet att inte injicera costCalculator via konstruktorn beror på att inte alla metoder i UsageAnalyzer behöver den och skulle få onödigt beroende. Trade-offen är att denna metod blir triadic, men varje metod är explicit om sina beroenden. **Command Query Separation:** Är en ren query utan sidoeffekter. |
| `calculateHourlyCost()`, `calculateMonthlyCost()`, `calculateYearlyCost()`, `calculateWeeklyCost()` | [src/CostCalculator.js](src/CostCalculator.js#L46) | 15, 12, 12, 12 | **Do One Thing:** Varje metod har ett tydligt ansvar - konvertera till specifik tidsfrekvens. **Function Arguments:** Monadic vilket är bra enligt Clean Code. **Structured Programming:** Använder flera returns istället för en exit point, vilket gör koden plattare och mer lättläst än djupt nästlade if/else-block. **Don't Repeat Yourself:** Duplicerad struktur mellan metoderna men med olika konverteringskunskap. **Förslag:** Extrahera till generisk metod `#convertCost(subscription, targetFrequency)`. **Valt:** Behålla separata metoder eftersom varje innehåller unik konverteringskunskap och en generisk lösning skulle skapa onödig komplexitet. |
| `constructor (Subscription)` | [src/Subscription.js](src/Subscription.js#L31) | 11 | **Do One Thing:** Konstruktorn initialiserar och validerar. **Function Arguments:** Polyadic (4 parametrar varav en med default) vilket inte är optimalt. **Förslag:** Configuration object `new Subscription({ name, price, frequency, category })` för att minska till 1 argument. **Valt:** Parameter-lista för enkelhet och tydlig ordning i denna modulstorlek. **Prefer Exceptions to Returning Error Codes:** Följer 'fail fast' genom att validera alla inputs och kastar exceptions före initialisering, vilket säkerställer att systemet endast innehåller giltiga Subscription-objekt. |
| `analyzeCostPerHour()` | [src/UsageAnalyzer.js](src/UsageAnalyzer.js#L17) | 6 | **Do One Thing:** Gör en sak - analyserar kostnad per timme. **Function Arguments:** Dyadic vilket är acceptabelt. **Förslag:** Injicera costCalculator via konstruktor. **Valt:** Parameter-passing för att hålla UsageAnalyzer oberoende av calculator för metoder som inte behöver den. **Prefer Exceptions to Returning Error Codes:** Kastar exception vid division med noll istället för att returnera felkod. **Command Query Separation:** Ren query utan sidoeffekter. |
| `addUsageHours()` | [src/Subscription.js](src/Subscription.js#L129) | 6 | **Do One Thing:** Gör en sak - lägger till timmar med validering. **Function Arguments:** Monadic vilket är bra. **Command Query Separation:** Är ett command som ändrar state utan att returnera värde, vilket följer CQS korrekt. **Have No Side Effects:** Tack vare det tydliga namnet (`add`) räknas state-förändringen inte som sidoeffekt eftersom metoden gör vad namnet lovar. **Prefer Exceptions to Returning Error Codes:** Kastar exception vid negativa värden istället för att returnera felkod. |


## Reflektion Kapitel 3: Funktioner
Under arbetet med modulen visade sig principerna 'Do One Thing' och 'Small functions' vara mer utmanande än jag förutsett. Jag har tidigare inte tänkt på metodansvar på detta sätt och det tvingade mig att omvärdera hur jag strukturerar kod. Generellt tycker jag att jag lyckats hålla ner komplexiteten och storleken på mina metoder, men det finns några exempel där jag medvetet valt att inte följa reglerna strikt (se tabell 2).

Ett exempel är 'calculateMonthlyCost()' som kan tyckas bryta mot 'Do One Thing' då den innehåller flera if satser för olika beräkningar. Men metodens logiska ansvar är en enda sak: att beräkna månadskostnaden. If satserna är implementationsdetaljer för att hantera olika frekvenser, och att dela upp metoden i separata funktioner skulle enligt mig göra koden svårare att följa. Jag har inga switch satser i modulen eftersom metoderna bara hanterar två till tre fall, och if/else kedjor ger bättre läsbarhet för denna enkla logik.

Jag arbetade medvetet med abstraktionsnivåer genom att använda privata hjälpmetoder. I 'calculateCostByCategory()' delegerar jag till '#filterActiveSubscriptions()' och '#groupCostsByCategory()' vilket håller den publika metoden på hög abstraktionsnivå medan hjälpmetoderna hanterar detaljer. På samma sätt använder 'searchSubscriptionsByName()' den privata metoden '#matchesName()' för att hantera lågnivålogiken med toLowerCase() och includes(). Detta följer principen om att läsa kod från topp till botten där användaren först ser vad som händer på hög nivå, sedan kan fördjupa sig i implementationen.

Command Query Separation var något jag aktivt tillämpade genom hela modulen. Metoder som 'activate()' och 'addUsageHours()' är kommandon som ändrar state utan att returnera värden, medan 'isActive()' och alla calculate metoder är queries som returnerar värden utan att ändra state. Det enda undantaget jag gjorde är 'removeSubscription()' som returnerar boolean för att indikera om borttagningen lyckades. Detta var ett aktivt val där jag prioriterade användbarheten framför att strikt följa principen.

En viktig insikt var min refaktorering av 'findUnusedSubscriptions()' från for-loop med push till filter(). Detta gav både kortare kod och högre abstraktionsnivå. För 'findUnderutilizedSubscriptions()' som hade liknande problematik övervägde jag method chaining, men insåg att ett 'tåg' av filter().map().filter() skulle dölja den komplexa logiken. For-loopen gör det tydligt att metoden både filtrerar och beräknar. Detta var en avvägning mellan högre abstraktion och explicit kod där jag för den ena metoden prioriterade enkelhet och för den andra prioriterade tydlighet.

I CostCalculator har beräkningsmetoderna liknande if/else struktur. När jag först såg detta mönster funderade jag på om det var ett brott mot DRY, men insåg vid närmare granskning att varje metod innehåller unik kunskap om sin specifika konvertering. Strukturen är samma men kunskapen är olika. Att extrahera till en generisk metod skulle göra koden mer komplex utan verkligt värde. Detta påminde mig om att DRY handlar om mer än duplicerad struktur.

Jag har arbetat med att hålla blocks and indenting enkla genom låga indenteringsnivåer och små funktioner. If/while block hålls korta och nästling undviks där det är möjligt genom att extrahera till privata metoder. Jag har även strukturerat klasserna så att publika metoder kommer först följt av privata hjälpmetoder, vilket underlättar för användaren att först förstå det publika interface.

Jag har strävat efter att använda beskrivande namn där namnet tydligt kommunicerar vad metoden gör och minskar behovet för kommentarer (något jag utvecklar mer i reflektionen över kapitel 2). För side effects har jag varit vaksam på att metoder gör exakt vad namnet lovar. Exempelvis kommunicerar addUsageHours() tydligt att state kommer att ändras.

För felhantering följer modulen strikt principen att föredra exceptions framför returvärden. Metoderna kastar exceptions med beskrivande meddelanden vid felaktig input istället för att returnera null eller felkoder. Detta gör felhanteringen tydligare och tvingar användaren att hantera fel korrekt med try/catch. Jag valde att validera tidigt i metoderna enligt 'fail fast' principen, vilket säkerställer att systemet endast innehåller giltiga objekt.


## Reflektion över egen kodkvalitet
Det har varit en väldigt lärorik process att tillämpa Clean Code-principer i utvecklingen av min modul. Under arbetet insåg jag hur givande och tidssparande det är med självdokumenterande kod, inte bara för andra utan även mig själv. Jag är van vid omfattande JSDoc-dokumentation enligt LNU-standard. Det var en märklig upplevelse att inse hur mycket av dokumentationen som blev överflödig när koden talar för sig själv.

Jag har strävat efter att skapa en välstrukturerad modul med tydlig separation of concerns med olika klasser för olika ansvarsområden, där jag använt privata metoder för att hålla publika metoder så små och fokuserade som möjligt, namngivna konstanter för att eliminera magiska nummer och konsekvent tillämpat Command Query Separation. Förbättringsområden finns naturligtvis både i koden och i min förståelse av principerna, vilket jag vill vara transparent med i den här reflektionen.

Genom denna assignment tar jag med mig vikten av att ’kommunicera lösningen, inte bara lösa problemet’. Den omfattande API-dokumentationen och de tydliga felmeddelanden som jag skapat hoppas jag kan hjälpa andra utvecklare förstå koden likväl som att få den att fungera.

Att analysera modulen utifrån Clean Code-perspektiv har varit en ögonöppnare och krävt mycket tankeverksamhet. I varje designval tvingades jag reflektera över hur en utomstående utvecklare ska förstå koden, vilket ställde mig inför konstanta vägskäl. Att följa Clean Code i alla avseenden har varit omöjligt för mig, vissa principer hamnar i konflikt med varandra, och jag har många gånger fått låta kontexten avgöra vilket val som är mest lämpligt. Alla beslut har nog inte varit 'rätt' men jag har reflekterat och lärt mig väldigt mycket på vägen. Det är jag tacksam för.